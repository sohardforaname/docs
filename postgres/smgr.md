# Postgresql的数据库文件与文件缓冲区管理

## 数据库文件

在文件系统中，一个数据库按照一个目录的方式存储，存储在$PGDATA/base/中，以数据库的OID作为目录名称。打开之后，会发现许多数字编号的文件及它们的fsm（空闲空间映射）和vm（可见性映射）文件。
根据和数据库命名类似的方式，这些数字编号的文件实际上是一个个对象的OID。比如说表和序列，在创建Postgresql数据库的时候，系统就已经创建了一些系统表。

Postgresql中initdb之后第一个创建的数据库是template1，OID保证为1，然后会创建template0和postgres数据库，这两个数据库的OID就是大于1之后的最小的两个数字编号。
除此之外还有PG_VERSION（数据库版本文件）和pg_filenode.map，表示对象OID和文件系统中的文件ID的映射文件。

为什么会需要pg_filenode.map的映射呢，虽然在创建数据对象初期，文件名是按照OID来命名的，但是当执行后truncate等命令之后，filenode将有可能发生变化。

数据文件中一个文件的最大大小是1GB，超过1GB之后，数据库将会为它创建更多的文件，并以relfilenode.1, relfilenode.2来保存。每一个数据文件都会对应着VM文件和FSM文件。

###  VM文件

VM文件即可见性文件。标记对所有的当前活跃事务都可见的元组，由于PG执行update和delete操作是懒惰删除操作，数据最终会通过vacuum阶段清理，通过这个标记，可以让vacuum跳过不存在需要删除的元组的页，提高并发性能。

### FSM文件

FSM文件即空闲空间映射文件，标记的是文件中的页上剩余的空间。
FSM文件由一棵孩子数量为4k的多叉树管理，每棵多叉树中使用二叉堆管理对应的节点组，通过大根堆可以把数据文件中最大的块上升到根节点处快速查询。并且使用了1：32的映射关系，即，一个FSM中的位置值表示以它乘32为开始的数据块中有空间。

### 数据文件

PG的数据文件以块为单位组织，默认是8KB一个块，块内包含一个块元数据，块元数据信息后面是tuple, tuple的指针从元数据后从前往后组织，实际的tuple数据则从后往前组织，当指针数据和tuple数据相遇时块充满。

而索引文件则有所不同，PG的索引文件（以btree索引为例）同样由元组组成，但是在数据页的最后留出了空间指向右边的页。元组中存放了索引键的值和指向的叶子节点的ID或者是回表的数据元组的ctid等。

## TOAST文件

TOAST(The Oversized Attribute Storage Technique，超尺寸字段存储技术)是一种用于存储超长的列的技术，由于PG的一个块的长度是8K，且元组不允许跨页，如果有超过了8K的字段长度，则PG会建立一张pg_toast系统表，并用于分段存放过长的字段。
TOAST策略分成4种：分别是PLAIN，EXTERNA，EXTENDED，MAIN；分别是是否允许压缩和行外存储的排列组合，如果开启了行外存储，在遇到过长的字段是，pg_toast表中就会将这些过长的字段值压缩和切片存储。

TOAST策略选择规则：
- 如果策略允许压缩，则TOAST优先选择压缩
- 不管是否压缩，一旦数据超过2KB左右，就会启用行外存储
- 修改TOAST策略，不会影响现有数据的存储方式

### pg_filenode.map文件

使用select relname, relfilenode from pg_class查询表的时候，会发现有些表的relfilenode是0，由于在每个数据库中都需要保存一个不同的同名表，这些表被称为Nail表，对于Nail表，我们无法直接查到relfilenode。
此时就需要使用一个文件记录这些表，pg_filenode.map就是这样的文件，通过查找这个文件，我们就可以获取这些Nail表的filenode。同时，对于全局系统表，我们也会使用一个global文件夹下的pg_filenode.map记录其filenode
pg_filenode.map文件的更新出现在三个时机：boot模式初始化整个数据库时；txn abort/commit时，并且事务对Nail表有更新；redo时。由于这个文件维护了对Nail表的filenode映射，恢复时需要使用，它的更改也是需要写WAL的。
同时，对文件的更改也需要同步更改缓存。

在数据库启动时，这个文件也会被加载，如果没有找到则PG会直接返回FATAL错误。同时，在pg_filenode.map需要写入时，它总是会先创建一个备份再写入，这是因为假如写入时出现宕机，需要使用这个备份结合WAL恢复，没有备份文件就没有回放起点。

## 行存表的文件读写系统（smgr, storage manager）

smgr本身是一个文件存储管理器抽象，它提供了一组回调函数操作不同的文件系统，只要实现这些接口，就可以使PG使用一个新的文件系统。其中包含一系列方法：
- smgropen：创建一个cache缓存对象SMgrRelation，缓存打开的文件，但是不进行任何文件读写操作
- smgrcreate：若数据库空间不存在，创建数据库空间，创建文件，初始化mdfdVec对象，确定数据库文件路径并设置md_fd。
- smgrread：打开分段文件，读取文件内容并校验
- smgrwrite：打开分段文件，写入文件内容，标记写入后的段为脏段。
- smgrclose：遍历所有记录的打开的文件，全部关闭并移除cache的缓存对象
- smgrtruncate：首先需要将截断的数据块从内存中的共享缓存处清楚，然后再在文件中将对应的数据块删除
- smgrextend：打开分段文件，如果当前段不存在则创建，然后写入文件内容到新的段中（可选），并标记脏段。

默认情况下，这个smgr最终都会调用md.c里面的函数执行真正的文件操作。

